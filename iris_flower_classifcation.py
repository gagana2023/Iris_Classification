# -*- coding: utf-8 -*-
"""iris_flower_classifcation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E-iugxTQYnovOFHlfSULfLfZ_Inu70yz
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

colnames=["sepal_length_in_cm", "sepal_width_in_cm","petal_length_in_cm","petal_width_in_cm", "class"]

#Read the dataset
dataset = pd.read_csv("https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data", header = None, names= colnames )

#Data
dataset.tail()

dataset = dataset.replace({"class":  {"Iris-setosa":1,"Iris-versicolor":2, "Iris-virginica":3}})
#Visualize the new dataset
dataset.head()

dataset.tail()

X = dataset.iloc[:,:-1]
y = dataset.iloc[:, -1].values

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 0)

from sklearn.svm import SVC
classifier = SVC(kernel = 'linear', random_state = 0)
#Fit the model for the data

classifier.fit(X_train,y_train)

# classifier.fit(rand, [1,2,3])


# #Make the prediction
y_pred = classifier.predict(X_test)

classifier.predict([[6.7	,3.0,	5.2	,2.3]])

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)
print(cm)

from sklearn.model_selection import cross_val_score


accuracies = cross_val_score(estimator = classifier, X = X_train, y = y_train, cv = 10)
print("Accuracy: {:.2f} %".format(accuracies.mean()*100))
print("Standard Deviation: {:.2f} %".format(accuracies.std()*100))

def get_output(input):
    input = list(map(int,input.split(",")))
    return classifier.predict(input)

!pip install colabcode 
!pip install fastapi

from colabcode import ColabCode       # A Python package that allows you to start a code server right from your Colab notebooks without setting up anything locally on your system
from fastapi import FastAPI     
cc  = ColabCode(port=1200,code=False)

app = FastAPI()                                                          #setting up the app
@app.get("/")
async def index():
    return {"message":"hey, have a nice day "}


@app.get("/{data}")                                                      #get function to get the string input from the user 
def predict_sentiment(data:str):

    # from sklearn.svm import SVC
    # classifier = SVC(kernel = 'linear', random_state = 0)
    # classifier.coef = [[-0.04627259,  0.52114901, -1.00303714, -0.46412669],
    #    [ 0.04016065,  0.16064259, -0.56224908, -0.24096389],
    #    [ 0.84531147,  0.72837956, -2.09462768, -1.83669367]]

    # classifier.intercept_ = [1.45298766, 1.34136571, 5.81626016] 

    input = list(map(float,data.split()))

    res =  classifier.predict([input])
    id = str(res[0])

    id2label = {"1": "Iris-setosa" , "2" :"Iris-versicolor" , "3": "Iris-virginica"}


 

    return {
        
        "predicted class" : id2label[id]
    }

    
    

    # text_list = [process_text(data)]                                     #processing the text to remove unwanted characters
    # testing_sequences = tokenizer.texts_to_sequences(text_list)          #coverts the text to sequence of numbers by using the tokenizer function
    # padded = pad_sequences(testing_sequences, maxlen=90, padding='post') #pads the sequence with zeros at the end to regularise the length of all the sequences to the maximum sequence length
    # prediction = model.predict(padded)                                   #feeding the padded sequence to the model for it give a prediction
    # if prediction[0][0]>=0.5:                                            #we consider prediction as positive if its value is greater than or equal to  0.5
    #     prediction = "Positive"
    # else:
    #     prediction = "Negative"                                          #we consider prediction as negative if its value is lesser than or equal to  0.5
    # return {
    #     "prediction" : res[0]
    # }

cc.run_app(app)

